{"version":3,"sources":["PathFindingVisualizer/Resources/right_arrow.jpg","PathFindingVisualizer/Resources/left_arrow.jpg","PathFindingVisualizer/Resources/WallCreation.gif","PathFindingVisualizer/Node/Node.jsx","PathFindingVisualizer/Tutorial.jsx","PathFindingVisualizer/Algorithms/BFS.js","PathFindingVisualizer/Algorithms/DFS.js","PathFindingVisualizer/Algorithms/Djikstra.js","PathFindingVisualizer/Algorithms/AStar.js","PathFindingVisualizer/Path.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","props","state","this","isFinish","isStart","isAnimated","row","col","isWall","onMouseDown","onMouseEnter","onMouseUp","isShortestPathNode","instantAnimation","onMouseOver","nodeWeight","extraClassName","id","className","Component","Tutorial","prop","currentSlide","show","alreadyHidden","handleClose","bind","currentVal","setState","console","log","Button","onClick","decrementCurrentSlide","src","leftArrow","height","width","incrementCurrentSlide","rightArrow","onChange","selectAlgorithm","value","selectSpeed","Modal","centered","onHide","Header","closeButton","Title","generateTitle","Body","generateBody","Footer","generateNextSectionButtons","BFS","grid","startNode","endNode","endRow","endCol","queueOfVisited","visitedInOrder","push","length","currentNode","shift","currentRow","currentCol","aboveNode","belowNode","leftNode","rightNode","DFS","stack","returnVisitedStack","pop","topNode","bottomNode","Dijkstra","countOfNodeNotVisited","minDistanceCoordinate","findMinimumDistanceInGrid","currentNodeDistance","aboveNodeDistance","toTopNodeDistance","bottomNodeDistance","toBottomNodeDistance","leftNodeDistance","toLeftNodeDistance","rightNodeDistance","toRightNodeDistance","currentMinimumDistance","currentMinDistanceCoordinate","currentDistance","constructShortestPath","StartNode","startRow","startCol","visitedStack","topNodeDistancePlusOne","bottomNodeDistancePlusOne","leftNodeDistancePlusOne","rightNodeDistancePlusOne","previousNodeCoords","AStar","findMinimumFDistance","estimatedCostToEnd","manhattanDistanceHeuristic","Math","abs","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","TIME_OUT_CONST","Path","nodes","mousePressed","algorithm","movingStartNode","previousStartNode","movingEndNode","previousEndNode","currentStartNode","currentEndNode","alreadyVisualized","inAnimation","addingWeight","visualizeDFS","visualizeBFS","setAddingWeight","instantNonAnimation","nodeObject","isTop","isBottom","GRID_ROW_LENGTH","isLeft","isRight","GRID_COL_LENGTH","isVisited","distance","previous","distanceSum","newGrid","slice","newNode","oldNoLongerStartNode","clearBoard","setTimeout","instantAnimationWithShortestPath","oldNoLongerEndNode","makeNewGridWithWeight","makeNewGridWithWall","visitedNode","animate","initialAnimationFinished","beforeTimeStartInterval","shortestPath","reverse","animateShortestPath","setTimeoutAgainFk","shouldSetTimeout","i","node","currentFinalNode","resetAlreadyVisualized","column","visualizeDjikstra","visualizeAStar","event","target","chosenSlide","wallCreation","message","visualizeAlgorithm","clearWall","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","handleMouseOver","App","Boolean","window","location","hostname","match","ReactDOM","render","basename","process","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.bddbbab9.chunk.js","sourcesContent":["module.exports = \"data:image/jpeg;base64,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\"","module.exports = \"data:image/jpeg;base64,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\"","module.exports = __webpack_public_path__ + \"static/media/WallCreation.62c45f33.gif\";","import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n    render() {\r\n        const {isFinish,\r\n            isStart,\r\n            isAnimated,\r\n            row,\r\n            col,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            isShortestPathNode,\r\n            instantAnimation,\r\n            onMouseOver,\r\n            nodeWeight,\r\n        } = this.props;\r\n        var extraClassName = isFinish ? 'node-finish':\r\n            isStart ? 'node-start':\r\n            isShortestPathNode ? 'node-shortest-path':\r\n            isAnimated ? 'node-visited':\r\n            isWall ? 'node-wall':\r\n            nodeWeight !== 1 ? 'node-weight':\r\n            '';\r\n        if (instantAnimation && !isStart && !isFinish) {\r\n            if (extraClassName === \"node-shortest-path\" || extraClassName === \"node-visited\") {\r\n                extraClassName += \"-instant-animation\"\r\n            }\r\n        }\r\n        return <div\r\n            id = {`node-${row}-${col}`}\r\n            className={`node ${extraClassName}`}\r\n            onMouseDown ={() => onMouseDown(row,col)}\r\n            onMouseEnter ={() => onMouseEnter(row,col)}\r\n            onMouseOver = {() => onMouseOver(row,col)}\r\n            onMouseUp = {() => onMouseUp(row,col)}>\r\n        </div>;\r\n    }\r\n}\r\n\r\nexport const DEFAULT_NODE = {\r\n    row: 0,\r\n    col: 0,\r\n};\r\n\r\n","import {Button} from \"react-bootstrap\";\r\nimport React, {Component} from 'react';\r\nimport Modal from \"react-bootstrap/Modal\";\r\nimport './Tutorial.css';\r\nimport rightArrow from \"./Resources/right_arrow.jpg\"\r\nimport leftArrow from \"./Resources/left_arrow.jpg\"\r\n// import React from \"react\";\r\n\r\nexport default class Tutorial extends Component {\r\n    constructor(prop) {\r\n        super(prop);\r\n        this.state = {\r\n            currentSlide: 0,\r\n            show:true,\r\n            alreadyHidden: false,\r\n        };\r\n        this.handleClose = this.handleClose.bind(this);\r\n    }\r\n\r\n    incrementCurrentSlide() {\r\n        var currentVal = this.state.currentSlide;\r\n        currentVal += 1;\r\n        this.setState({currentSlide: currentVal});\r\n    }\r\n\r\n    decrementCurrentSlide() {\r\n        var currentVal = this.state.currentSlide;\r\n        currentVal -= 1;\r\n        this.setState({currentSlide: currentVal});\r\n        console.log()\r\n    }\r\n\r\n    generateNextSectionButtons() {\r\n        return (\r\n            <div className='backOrNextSection'>\r\n                <Button className='backButton' onClick={() => this.decrementCurrentSlide()}>\r\n                <img src={leftArrow} height={50} width={50}>\r\n                </img>\r\n                </Button>\r\n                <Button className='nextButton' onClick={() => this.incrementCurrentSlide()}>\r\n                <img src={rightArrow} height={50} width={50}>\r\n                </img>\r\n                </Button>\r\n             </div>\r\n        )\r\n    }\r\n\r\n    generateBody() {\r\n        if (this.state.currentSlide === 0) {\r\n            return (\r\n                <div>\r\n                    Welcome to my pathfinding visualizer. The goal of this website is to demonstrate how path algorithms arrive at their destination by illustrating the steps they take.\r\n                </div>\r\n            )\r\n        } else if (this.state.currentSlide === 1) {\r\n            return (\r\n                <div>\r\n                    A Pathfinding algorithms are usually an attempt to solve the shortest path problem. They try to find the best path given a starting point and ending point based on some predefined criteria.\r\n                    <br></br>\r\n                    Different pathfinding algorithm have different purposes. For example, Djikstra is used to find the shortest path with positive weights while\r\n                    Bellman-Ford is used to find the shortest path in a graph with negative weights.\r\n                </div>\r\n            )\r\n        } else if(this.state.currentSlide === 2) {\r\n            return (\r\n                <div>\r\n                    All of the boxes on this grid represents a node and the default value to move from one node to another is 1. This can be changed via add weight option when an algorithm allows it.\r\n                </div>\r\n            )\r\n        } else if (this.state.currentSlide ===3) {\r\n            return (\r\n                <div className='tutorialLayout'>\r\n                    <Button className=\"button\">\r\n                        Visualize\r\n                    </Button>\r\n                    <p>\r\n                    Used to begin the animation\r\n                    </p>\r\n                    <Button className=\"button\">\r\n                        Clear Board\r\n                    </Button>\r\n                    <p>\r\n                    Used to clear all the visited node\r\n                    </p>\r\n                    <Button className=\"button\">\r\n                        Clear Wall\r\n                    </Button>\r\n                    <p>\r\n                    Used to clear wall\r\n                    </p>\r\n                    <Button className=\"button\">\r\n                        Add Weight\r\n                    </Button>\r\n                    <p>\r\n                    Used to switch from adding wall to adding weight\r\n                    </p>\r\n                </div>\r\n            )\r\n        } else if (this.state.currentSlide === 4) {\r\n            return (\r\n                <div className=\"tutorialLayout\">\r\n                    <Button className=\"button\">\r\n                        <div className =\"dropdown\">\r\n                            <select className =\"AlgorithmSelect\" onChange={this.selectAlgorithm}>\r\n                                <option value=\"BFS\"> BFS</option>\r\n                                <option value=\"DFS\"> DFS</option>\r\n                                <option value=\"Djikstra\"> Djikstra </option>\r\n                                <option value=\"AStar\"> A* </option>\r\n                            </select>\r\n                        </div>\r\n                    </Button>\r\n                    <p>\r\n                        Used to select which algorithm to visualize\r\n                    </p>\r\n                    <Button className=\"button\">\r\n                        <div className =\"dropdown\">\r\n                            Speed:\r\n                            <select className = \"AlgorithmSelect\" onChange = {this.selectSpeed} >\r\n                                <option value=\"Fast\"> Fast </option>\r\n                                <option value=\"Slow\"> Slow </option>\r\n                                <option value=\"Average\"> Average </option>\r\n                            </select>\r\n                        </div>\r\n                    </Button>\r\n                    <p>\r\n                        Used to how fast the visualization runs\r\n                    </p>\r\n                </div>\r\n            )\r\n        } else if (!this.state.alreadyHidden) {\r\n            this.handleClose();\r\n            this.setState({alreadyHidden:true})\r\n        }\r\n    }\r\n\r\n    generateTitle() {\r\n        if (this.state.currentSlide === 0) {\r\n            return (\r\n                <div>\r\n                    Introduction\r\n                </div>\r\n            )\r\n        } else if (this.state.currentSlide === 1) {\r\n            return (\r\n                <div>\r\n                    What are pathfinding algorithms?\r\n                </div>\r\n            )\r\n        } else if (this.state.currentSlide === 2) {\r\n            return (\r\n                <div>\r\n                    Grid layout\r\n                </div>\r\n            )\r\n        } else if (this.state.currentSlide === 3) {\r\n            return (\r\n                <div>\r\n                    Buttons\r\n                </div>\r\n            )\r\n        } else if (this.state.currentSlide === 4) {\r\n            return (\r\n                <div>\r\n                    Dropdown\r\n                </div>\r\n            )\r\n        }\r\n    }\r\n\r\n    handleClose() {\r\n        this.setState({show:false});\r\n    }\r\n\r\n    render() {\r\n        const {show} = this.state;\r\n        return (\r\n            <>\r\n            <Modal show={show} centered={true} onHide={() => this.handleClose()}>\r\n                <Modal.Header closeButton>\r\n                    <Modal.Title>{this.generateTitle()}</Modal.Title>\r\n                </Modal.Header>\r\n                <Modal.Body>{this.generateBody()}</Modal.Body>\r\n                <Modal.Footer>\r\n                    {this.generateNextSectionButtons()}\r\n                </Modal.Footer>\r\n            </Modal>\r\n            </>\r\n        )\r\n    }\r\n}","\r\nexport function BFS(grid, startNode, endNode) {\r\n    const {row,col} = startNode;\r\n    const endRow = endNode['row'];\r\n    const endCol = endNode['col'];\r\n    const queueOfVisited = [];\r\n    const visitedInOrder = [];\r\n    if (grid != null && startNode != null) {\r\n        queueOfVisited.push(startNode);\r\n    }\r\n    while (queueOfVisited.length > 0) {\r\n        const currentNode = queueOfVisited.shift();\r\n        const currentRow = currentNode['row'];\r\n        const currentCol = currentNode['col'];\r\n        visitedInOrder.push(currentNode);\r\n        currentNode['isVisited'] = true;\r\n        if (currentRow === endRow && currentCol === endCol) {\r\n            return visitedInOrder;\r\n        }\r\n        if (currentNode['isTop'] === false) {\r\n            const aboveNode = grid[currentRow-1][currentCol];\r\n            if (aboveNode['isVisited'] === false && !aboveNode['isWall']) {\r\n                queueOfVisited.push(aboveNode);\r\n                aboveNode['isVisited'] = true;\r\n            }\r\n        }\r\n        if (currentNode['isBottom'] === false) {\r\n            const belowNode = grid[currentRow+1][currentCol];\r\n            if (belowNode['isVisited'] === false && !belowNode['isWall']) {\r\n                queueOfVisited.push(belowNode);\r\n                belowNode['isVisited'] = true;\r\n            }\r\n        }\r\n        if (currentNode['isLeft'] === false) {\r\n            const leftNode = grid[currentRow][currentCol-1];\r\n            if (leftNode['isVisited'] === false && !leftNode['isWall']) {\r\n                queueOfVisited.push(leftNode);\r\n                leftNode['isVisited'] = true;\r\n            }\r\n        }\r\n        if (currentNode['isRight'] === false) {\r\n            const rightNode = grid[currentRow][currentCol+1];\r\n            if (rightNode['isVisited'] === false && !rightNode['isWall']) {\r\n                queueOfVisited.push(rightNode);\r\n                rightNode['isVisited'] = true;\r\n            }\r\n        }\r\n    }\r\n    return visitedInOrder;\r\n}\r\n\r\n","export function DFS(grid, startNode, endNode) {\n    const{row,col} = startNode;\n    const endRow = endNode['row'];\n    const endCol = endNode['col'];\n    var stack =[];\n    var returnVisitedStack = [];\n    if (grid != null && startNode != null) {\n        stack.push(startNode);\n    }\n    console.log(stack);\n    while (stack.length > 0) {\n        const currentNode = stack.pop();\n        returnVisitedStack.push(currentNode);\n        if (currentNode['isVisited'] === false) {\n            currentNode['isVisited'] = true;\n            const currentRow = currentNode['row'];\n            const currentCol = currentNode['col'];\n            if (currentRow === endRow && currentCol === endCol) {\n                return returnVisitedStack;\n            } else {\n                if (currentNode['isTop'] === false) {\n                    const topNode = grid[currentRow - 1][currentCol];\n                    if (topNode['isVisited'] === false && !topNode['isWall']) {\n                        stack.push(topNode);\n                    }\n                }\n                if (currentNode['isBottom'] === false) {\n                    const bottomNode = grid[currentRow + 1][currentCol];\n                    if (bottomNode['isVisited'] === false && !bottomNode['isWall']) {\n                        stack.push(bottomNode);\n                    }\n                }\n                if (currentNode['isLeft'] === false) {\n                    const leftNode = grid[currentRow][currentCol - 1];\n                    if (leftNode['isVisited'] === false && !leftNode['isWall']) {\n                        stack.push(leftNode);\n                    }\n                }\n                if (currentNode['isRight'] === false) {\n                    const rightNode = grid[currentRow][currentCol + 1];\n                    if (rightNode['isVisited'] === false && !rightNode['isWall']) {\n                        stack.push(rightNode);\n                    }\n                }\n            }\n        }\n    }\n    return returnVisitedStack;\n}","// export function Dijkstra(grid, startNode, endNode) {\n//     const {row,col} = startNode;\n//     const endRow = endNode['row'];\n//     const endCol = endNode['col'];\n//     const queueOfVisited = [];\n//     // console.log(grid);\n//     const visitedInOrder = [];\n//     if (grid != null && startNode != null) {\n//         queueOfVisited.push(startNode);\n//     }\n//     while (queueOfVisited.length > 0) {\n//         findMinimumDistanceInGrid(grid);\n//         const currentNode = queueOfVisited.shift();\n//         visitedInOrder.push(currentNode);\n//         // if (currentNode['col'] === 4) {\n//         //     if(currentNode['row'] === 2) {\n//         //         console.log('2,4');\n//         //     }\n//         //     if (currentNode['row'] === 3) {\n//         //         console.log('3,4');\n//         //     }\n//         // }\n//         if (!currentNode['isVisited']) {\n//             const currentRow = currentNode['row'];\n//             const currentCol = currentNode['col'];\n//             const currentDistance = currentNode['distance'];\n//             // var nextDistance = currentDistance + currentNode['nodeWeight'];\n//             if (currentNode['isTop'] === false) {\n//                 const aboveNode = grid[currentRow - 1][currentCol];\n//                 if (!aboveNode['isWall']) {\n//                     if (aboveNode['isVisited'] === false) {\n//                         queueOfVisited.push(aboveNode);\n//                     }\n//                     const aboveNodeDistance = aboveNode['distance'];\n//                     const nextDistance = currentDistance + aboveNode['nodeWeight'];\n//                     if (currentNode['row'] === 3 && currentNode['col'] === 4) {\n//                         console.log(\"Above node weight is \" + aboveNode['nodeWeight']);\n//                         console.log(\"From current to above node is \" + nextDistance);\n//                         console.log(\"Top node current distance is \" + aboveNodeDistance);\n//                         console.log(\"Current distance is \" + currentDistance);\n//                     }\n//                     if ( nextDistance < aboveNodeDistance) {\n//                         aboveNode['distance'] = nextDistance;\n//                         aboveNode['previous'] = [currentRow, currentCol];\n//                     }\n//                 }\n//             }\n//             if (currentNode['isBottom'] === false) {\n//                 const belowNode = grid[currentRow + 1][currentCol];\n//                 if (!belowNode['isWall']) {\n//                     if (belowNode['isVisited'] === false) {\n//                         queueOfVisited.push(belowNode);\n//                     }\n//                     const belowNodeDistance = belowNode['distance'];\n//                     const nextDistance = currentDistance + belowNode['nodeWeight'];\n//                     if (nextDistance < belowNodeDistance) {\n//                         belowNode['distance'] = nextDistance;\n//                         belowNode['previous'] = [currentRow, currentCol];\n//                     }\n//                 }\n//             }\n//             if (currentNode['isLeft'] === false) {\n//                 const leftNode = grid[currentRow][currentCol - 1];\n//                 if (!leftNode['isWall']) {\n//                     if (leftNode['isVisited'] === false) {\n//                         queueOfVisited.push(leftNode);\n//                     }\n//                     const leftNodeDistance = leftNode['distance'];\n//                     const nextDistance = currentDistance + leftNode['nodeWeight'];\n//                     if (nextDistance < leftNodeDistance) {\n//                         leftNode['distance'] = nextDistance;\n//                         leftNode['previous'] = [currentRow, currentCol];\n//                     }\n//                 }\n//             }\n//             if (currentNode['isRight'] === false) {\n//                 const rightNode = grid[currentRow][currentCol + 1];\n//                 if (!rightNode['isWall']) {\n//                     if (rightNode['isVisited'] === false) {\n//                         queueOfVisited.push(rightNode);\n//                     }\n//                     const rightNodeDistance = rightNode['distance'];\n//                     const nextDistance = currentDistance + rightNode['nodeWeight'];\n//                     if (nextDistance < rightNodeDistance) {\n//                         rightNode['distance'] = nextDistance;\n//                         rightNode['previous'] = [currentRow, currentCol];\n//                     }\n//                 }\n//             }\n//             currentNode['isVisited'] = true;\n//         }\n//     }\n//     return visitedInOrder;\n// }\n\nexport function Dijkstra(grid, startNode, endNode) {\n    const {row,col} = startNode;\n    const endRow = endNode['row'];\n    const endCol = endNode['col'];\n    var countOfNodeNotVisited = grid.length * grid[0].length;\n    const queueOfVisited = [];\n    const visitedInOrder = [];\n    if (grid != null && startNode != null) {\n        queueOfVisited.push(startNode);\n    }\n    while (countOfNodeNotVisited > 0) {\n        const minDistanceCoordinate = findMinimumDistanceInGrid(grid);\n        if (minDistanceCoordinate.length > 0) {\n            const currentNode = grid[minDistanceCoordinate[0]][minDistanceCoordinate[1]];\n            const currentNodeDistance = currentNode['distance'];\n            const currentRow = minDistanceCoordinate[0];\n            const currentCol = minDistanceCoordinate[1];\n            if (!currentNode['isWall']) {\n                if (!currentNode['isTop']) {\n                    const aboveNode = grid[currentRow - 1][currentCol];\n                    if (!aboveNode['isWall']) {\n                        const aboveNodeDistance = aboveNode['distance'];\n                        const aboveNodeWeight = aboveNode['nodeWeight'];\n                        const toTopNodeDistance = currentNodeDistance + aboveNodeWeight;\n                        if (toTopNodeDistance < aboveNodeDistance) {\n                            aboveNode['distance'] = toTopNodeDistance;\n                            aboveNode['previous'] = [currentRow, currentCol];\n                        }\n                    }\n                }\n                if (!currentNode['isBottom']) {\n                    const bottomNode = grid[currentRow + 1][currentCol];\n                    if (!bottomNode['isWall']) {\n                        const bottomNodeDistance = bottomNode['distance'];\n                        const bottomNodeWeight = bottomNode['nodeWeight'];\n                        const toBottomNodeDistance = currentNodeDistance + bottomNodeWeight;\n                        if (toBottomNodeDistance < bottomNodeDistance) {\n                            bottomNode['distance'] = toBottomNodeDistance;\n                            bottomNode['previous'] = [currentRow, currentCol];\n                        }\n                    }\n                }\n                if (!currentNode['isLeft']) {\n                    const leftNode = grid[currentRow][currentCol - 1];\n                    if (!leftNode['isWall']) {\n                        const leftNodeDistance = leftNode['distance'];\n                        const leftNodeWeight = leftNode['nodeWeight'];\n                        const toLeftNodeDistance = currentNodeDistance + leftNodeWeight;\n                        if (toLeftNodeDistance < leftNodeDistance) {\n                            leftNode['distance'] = toLeftNodeDistance;\n                            leftNode['previous'] = [currentRow, currentCol];\n                        }\n                    }\n                }\n                if (!currentNode['isRight']) {\n                    const rightNode = grid[currentRow][currentCol + 1];\n                    if (!rightNode['isWall']) {\n                        const rightNodeDistance = rightNode['distance'];\n                        const rightNodeWeight = rightNode['nodeWeight'];\n                        const toRightNodeDistance = currentNodeDistance + rightNodeWeight;\n                        if (toRightNodeDistance < rightNodeDistance) {\n                            rightNode['distance'] = toRightNodeDistance;\n                            rightNode['previous'] = [currentRow, currentCol];\n                        }\n                    }\n                }\n                visitedInOrder.push(currentNode);\n                currentNode['isVisited'] = true;\n            }\n        }\n        countOfNodeNotVisited -= 1;\n    }\n    console.log(\"finished the loop\");\n    console.log(grid);\n    return visitedInOrder;\n}\n\nfunction findMinimumDistanceInGrid(grid) {\n    var currentMinimumDistance = 99999999999;\n    var currentMinDistanceCoordinate = [];\n    for (let row = 0; row < grid.length; row ++) {\n        const currentRow = grid[row];\n        for (let col = 0; col < currentRow.length; col ++) {\n            const currentNode = currentRow[col];\n            if (!currentNode['isVisited'] && !currentNode['isWall']) {\n                const currentDistance = currentNode['distance'];\n                if (currentDistance < currentMinimumDistance) {\n                    currentMinimumDistance = currentDistance;\n                    currentMinDistanceCoordinate = [currentNode['row'], currentNode['col']]\n                }\n            }\n        }\n    }\n    console.log(\"current smallest distance in grid is \" + currentMinimumDistance);\n    console.log(\"The coordinate is \" + currentMinDistanceCoordinate);\n    return currentMinDistanceCoordinate;\n}\n\nexport function constructShortestPath(grid,StartNode,endNode) {\n    const startRow = StartNode['row'];\n    const startCol = StartNode['col'];\n    var currentNode = endNode;\n    var visitedStack = [];\n    const currentRow = endNode['row'];\n    const currentCol = endNode['col'];\n    if (!endNode['isTop']) {\n        const topNode = grid[currentRow - 1][currentCol];\n        const topNodeDistancePlusOne = topNode['distance'] + 1;\n        if (topNodeDistancePlusOne < endNode['distance']) {\n            endNode['distance'] = topNodeDistancePlusOne;\n            endNode['previous'] = [topNode['row'], topNode['col']];\n        }\n    }\n    if (!endNode['isBottom']) {\n        const bottomNode = grid[currentRow + 1][currentCol];\n        const bottomNodeDistancePlusOne = bottomNode['distance'] + 1;\n        if (bottomNodeDistancePlusOne < endNode['distance']) {\n            endNode['distance'] = bottomNodeDistancePlusOne;\n            endNode['previous'] = [bottomNode['row'], bottomNode['col']];\n        }\n    }\n    if (!endNode['isLeft']){\n        const leftNode = grid[currentRow][currentCol - 1];\n        const leftNodeDistancePlusOne = leftNode['distance'] + 1;\n        if (leftNodeDistancePlusOne < endNode['distance']) {\n            endNode['distance'] = leftNodeDistancePlusOne;\n            endNode['previous'] = [leftNode['row'], leftNode['col']];\n        }\n    }\n    if (!endNode['isRight']) {\n        const rightNode = grid[currentRow][currentCol + 1];\n        const rightNodeDistancePlusOne = rightNode['distance'] + 1;\n        if (rightNodeDistancePlusOne < endNode['distance']) {\n            endNode['distance'] = rightNodeDistancePlusOne;\n            endNode['previous'] = [rightNode['row'], rightNode['col']];\n        }\n    }\n    while (currentNode != null) {\n        if (currentNode['distance'] === 99999999) {\n            return \"No path exist\";\n        } else {\n            const currentRow = currentNode['row'];\n            const currentCol = currentNode['col'];\n            if (currentRow === startRow && currentCol === startCol) {\n                return visitedStack;\n            } else {\n                const previousNodeCoords = currentNode['previous'];\n                currentNode = grid[previousNodeCoords[0]][previousNodeCoords[1]]\n            }\n            visitedStack.push(currentNode);\n        }\n    }\n    return visitedStack;\n}","// Note to self:\r\n// Implementing AStar according to this website\r\n// https://www.geeksforgeeks.org/a-search-algorithm/\r\n// node.distance = g\r\n// h does not exist as a field but is calculated at run time.(manhattanDistanceHeuristic)\r\n// node.distanceSum = f\r\n// Their open list, I will denote as visited or unvisited as a property of the node\r\n// So open list = node.visited = false\r\n// closed list = node.visited = true\r\nexport function AStar(grid, startNode, endNode) {\r\n    const {row,col} = startNode;\r\n    const endRow = endNode['row'];\r\n    const endCol = endNode['col'];\r\n    var countOfNodeNotVisited = grid.length * grid[0].length;\r\n    const queueOfVisited = [];\r\n    const visitedInOrder = [];\r\n    if (grid != null && startNode != null) {\r\n        queueOfVisited.push(startNode);\r\n    }\r\n    while (countOfNodeNotVisited > 0) {\r\n        const minDistanceCoordinate = findMinimumFDistance(grid);\r\n        if (minDistanceCoordinate.length > 0) {\r\n            const currentNode = grid[minDistanceCoordinate[0]][minDistanceCoordinate[1]];\r\n            const currentNodeDistance = currentNode['distance'];\r\n            const currentRow = minDistanceCoordinate[0];\r\n            const currentCol = minDistanceCoordinate[1];\r\n            if (!currentNode['isWall']) {\r\n                if (!currentNode['isTop']) {\r\n                    const aboveNode = grid[currentRow - 1][currentCol];\r\n                    if (!aboveNode['isWall']) {\r\n                        const aboveNodeDistance = aboveNode['distance'];\r\n                        const aboveNodeWeight = aboveNode['nodeWeight'];\r\n                        const toTopNodeDistance = currentNodeDistance + aboveNodeWeight;\r\n                        // if (toTopNodeDistance < aboveNodeDistance) {\r\n                        //     aboveNode['distance'] = toTopNodeDistance;\r\n                        //     aboveNode['previous'] = [currentRow, currentCol];\r\n                        // }\r\n                        // g = toTopNodeDistance\r\n                        // h = manhattanDistanceHeuristic\r\n                        const estimatedCostToEnd = manhattanDistanceHeuristic(aboveNode, endNode) + toTopNodeDistance;\r\n                        if (estimatedCostToEnd < aboveNode['distanceSum']) {\r\n                            aboveNode['distanceSum'] = estimatedCostToEnd;\r\n                            aboveNode['distance'] = toTopNodeDistance;\r\n                            aboveNode['previous'] = [currentRow, currentCol];\r\n                        }\r\n                    }\r\n                }\r\n                if (!currentNode['isBottom']) {\r\n                    const bottomNode = grid[currentRow + 1][currentCol];\r\n                    if (!bottomNode['isWall']) {\r\n                        const bottomNodeDistance = bottomNode['distance'];\r\n                        const bottomNodeWeight = bottomNode['nodeWeight'];\r\n                        const toBottomNodeDistance = currentNodeDistance + bottomNodeWeight;\r\n                        // if (toBottomNodeDistance < bottomNodeDistance) {\r\n                        //     bottomNode['distance'] = toBottomNodeDistance;\r\n                        //     bottomNode['previous'] = [currentRow, currentCol];\r\n                        // }\r\n                        const estimatedCostToEnd = manhattanDistanceHeuristic(bottomNode, endNode) + toBottomNodeDistance;\r\n                        if (estimatedCostToEnd < bottomNode['distanceSum']) {\r\n                            bottomNode['distanceSum'] = estimatedCostToEnd;\r\n                                bottomNode['distance'] = toBottomNodeDistance;\r\n                                bottomNode['previous'] = [currentRow, currentCol];\r\n                        }\r\n                    }\r\n                }\r\n                if (!currentNode['isLeft']) {\r\n                    const leftNode = grid[currentRow][currentCol - 1];\r\n                    if (!leftNode['isWall']) {\r\n                        const leftNodeDistance = leftNode['distance'];\r\n                        const leftNodeWeight = leftNode['nodeWeight'];\r\n                        const toLeftNodeDistance = currentNodeDistance + leftNodeWeight;\r\n                        // if (toLeftNodeDistance < leftNodeDistance) {\r\n                        //     leftNode['distance'] = toLeftNodeDistance;\r\n                        //     leftNode['previous'] = [currentRow, currentCol];\r\n                        // }\r\n                        const estimatedCostToEnd = manhattanDistanceHeuristic(leftNode, endNode) + toLeftNodeDistance;\r\n                        if (estimatedCostToEnd < leftNode['distanceSum']) {\r\n                            leftNode['distanceSum'] = estimatedCostToEnd;\r\n                            leftNode['distance'] = toLeftNodeDistance;\r\n                            leftNode['previous'] = [currentRow, currentCol];\r\n                        }\r\n                    }\r\n                }\r\n                if (!currentNode['isRight']) {\r\n                    const rightNode = grid[currentRow][currentCol + 1];\r\n                    if (!rightNode['isWall']) {\r\n                        const rightNodeDistance = rightNode['distance'];\r\n                        const rightNodeWeight = rightNode['nodeWeight'];\r\n                        const toRightNodeDistance = currentNodeDistance + rightNodeWeight;\r\n                        // if (toRightNodeDistance < rightNodeDistance) {\r\n                        //     rightNode['distance'] = toRightNodeDistance;\r\n                        //     rightNode['previous'] = [currentRow, currentCol];\r\n                        // }\r\n                        const estimatedCostToEnd = manhattanDistanceHeuristic(rightNode, endNode) + toRightNodeDistance;\r\n                        if (estimatedCostToEnd < rightNode['distanceSum']) {\r\n                            rightNode['distanceSum'] = estimatedCostToEnd;\r\n                            rightNode['distance'] = toRightNodeDistance;\r\n                            rightNode['previous'] = [currentRow, currentCol];\r\n                        }\r\n                    }\r\n                }\r\n                visitedInOrder.push(currentNode);\r\n                currentNode['isVisited'] = true;\r\n            }\r\n        }\r\n        countOfNodeNotVisited -= 1;\r\n    }\r\n    console.log(\"finished the loop\");\r\n    console.log(grid);\r\n    return visitedInOrder;\r\n}\r\n\r\nfunction findMinimumFDistance(grid) {\r\n    var currentMinimumDistance = 99999999999;\r\n    var currentMinDistanceCoordinate = [];\r\n    for (let row =0; row < grid.length; row ++) {\r\n        const currentRow = grid[row];\r\n        for (let col = 0; col < currentRow.length; col ++) {\r\n            const currentNode = currentRow[col];\r\n            if (!currentNode['isVisited'] && !currentNode['isWall']) {\r\n                const currentDistance = currentNode['distanceSum'];\r\n                if (currentDistance < currentMinimumDistance) {\r\n                    currentMinimumDistance = currentDistance;\r\n                    currentMinDistanceCoordinate = [currentNode['row'], currentNode['col']]\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return currentMinDistanceCoordinate;\r\n}\r\n\r\nfunction manhattanDistanceHeuristic(currentNode, endNode) {\r\n    return (Math.abs(currentNode['row'] - endNode['row']) + Math.abs(currentNode['col'] - endNode['col']))\r\n}","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport Tutorial from './Tutorial';\r\n\r\nimport './Path.css'\r\nimport {BFS} from './Algorithms/BFS';\r\nimport {DFS} from \"./Algorithms/DFS\";\r\nimport {constructShortestPath, Dijkstra} from \"./Algorithms/Djikstra\"\r\nimport {AStar} from \"./Algorithms/AStar\";\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport {Button} from 'react-bootstrap';\r\n// import Popup from \"reactjs-popup\";\r\nimport wallCreation from './Resources/WallCreation.gif'\r\nimport Modal from \"react-bootstrap/Modal\";\r\n\r\n\r\nconst START_NODE_ROW = 0;\r\nconst START_NODE_COL = 0;\r\nconst FINISH_NODE_ROW = 3;\r\nconst FINISH_NODE_COL = 0;\r\nconst GRID_ROW_LENGTH = 30;\r\nconst GRID_COL_LENGTH = 60;\r\n// const GRID_ROW_LENGTH = 10;\r\n// const GRID_COL_LENGTH = 10;\r\nvar TIME_OUT_CONST = 25;\r\n\r\n\r\nexport default class Path extends Component {\r\n    constructor(prop) {\r\n        super(prop);\r\n        this.state = {\r\n            nodes: [],\r\n            mousePressed: false,\r\n            algorithm: \"BFS\",\r\n            movingStartNode: false,\r\n            previousStartNode: [START_NODE_ROW, START_NODE_COL],\r\n            movingEndNode: false,\r\n            previousEndNode: [FINISH_NODE_ROW, FINISH_NODE_COL],\r\n            currentStartNode: [START_NODE_ROW, START_NODE_COL],\r\n            currentEndNode: [FINISH_NODE_ROW, FINISH_NODE_COL],\r\n            alreadyVisualized: false,\r\n            inAnimation: false,\r\n            addingWeight: false,\r\n            currentSlide: 0,\r\n        };\r\n        this.selectAlgorithm = this.selectAlgorithm.bind(this);\r\n        this.visualizeDFS = this.visualizeDFS.bind(this);\r\n        this.visualizeBFS = this.visualizeBFS.bind(this);\r\n        this.setAddingWeight = this.setAddingWeight.bind(this);\r\n        this.instantNonAnimation = this.instantNonAnimation.bind(this);\r\n        this.incrementCurrentSlide = this.incrementCurrentSlide.bind(this);\r\n        this.decrementCurrentSlide = this.decrementCurrentSlide.bind(this);\r\n    }\r\n\r\n    setAddingWeight() {\r\n        this.setState({addingWeight:!this.state.addingWeight});\r\n    }\r\n\r\n    componentDidMount() {\r\n        const {currentStartNode, currentEndNode} = this.state;\r\n        const nodes = [];\r\n        for (let row = 0; row < GRID_ROW_LENGTH; row++) {\r\n            const currentRow = [];\r\n            for (let col = 0; col < GRID_COL_LENGTH; col++) {\r\n                const nodeObject = {\r\n                    row,\r\n                    col,\r\n                    isStart: row === currentStartNode[0] && col === currentStartNode[1],\r\n                    isFinish: row === currentEndNode[0] && col === currentEndNode[1],\r\n                    isTop: row === 0,\r\n                    isBottom: row === GRID_ROW_LENGTH-1,\r\n                    isLeft: col === 0,\r\n                    isRight: col === GRID_COL_LENGTH-1,\r\n                    isVisited: false,\r\n                    isAnimated: false,\r\n                    isWall: false,\r\n                    distance: row === currentStartNode[0] && col === currentStartNode[1] ? 0 : 99999999,\r\n                    previous : [null,null],\r\n                    isShortestPathNode: false,\r\n                    instantAnimation: false,\r\n                    nodeWeight: 1,\r\n                    distanceSum: row === currentStartNode[0] && col === currentStartNode[1] ? 0 : 99999999,\r\n                };\r\n                currentRow.push(nodeObject)\r\n            }\r\n            nodes.push(currentRow)\r\n        }\r\n        this.setState({nodes});\r\n    }\r\n\r\n    handleMouseDown(row,col) {\r\n        const mousePressed = this.state.mousePressed;\r\n        if (this.state.nodes[row][col].isStart) {\r\n            // console.log(\"Start Node Move\");\r\n            this.setState({movingStartNode:true, previousStartNode: [row,col]});\r\n            return;\r\n        } else if (this.state.nodes[row][col].isFinish) {\r\n            // console.log(\"End Node Move\");\r\n            this.setState({movingEndNode:true, previousEndNode: [row,col]});\r\n            return;\r\n        }\r\n        this.setState({mousePressed: !mousePressed});\r\n    }\r\n\r\n    handleMouseUp(row,col) {\r\n        const {previousStartNode, previousEndNode} = this.state;\r\n        this.setState({mousePressed:false, movingStartNode:false, movingEndNode:false});\r\n    }\r\n\r\n    handleMouseOver(row,col) {\r\n        const {previousStartNode, previousEndNode} = this.state;\r\n        if (this.state.movingStartNode) {\r\n            // console.log(\"Moving start Node\");\r\n            const newGrid = this.state.nodes.slice();\r\n            const currentNode = this.state.nodes[row][col];\r\n            const newNode = {\r\n                ...currentNode,\r\n                isStart: true,\r\n                distance: 0,\r\n            };\r\n            const oldStartNode = this.state.nodes[previousStartNode[0]][previousStartNode[1]];\r\n            const oldNoLongerStartNode = {\r\n                ...oldStartNode,\r\n                isStart: false,\r\n                distance: 99999999,\r\n            };\r\n            newGrid[row][col] = newNode;\r\n            newGrid[previousStartNode[0]][previousStartNode[1]] = oldNoLongerStartNode;\r\n            this.setState({nodes:newGrid, currentStartNode: [newNode.row,newNode.col], previousStartNode:[newNode.row, newNode.col]});\r\n            this.clearBoard();\r\n\r\n            // console.log(\"Start node instant animation\");\r\n            // console.log(\"Current algorithm is\" + this.state.algorithm + \" alreadyVisualized = \" + this.state.alreadyVisualized);\r\n            if ((this.state.algorithm === \"Djikstra\" || this.state.algorithm === \"AStar\") && this.state.alreadyVisualized) {\r\n                setTimeout(() => {\r\n                    // this.clearBoard();\r\n                    this.instantAnimationWithShortestPath();\r\n                }, 0)\r\n            } else if ((this.state.algorithm === \"DFS\" || this.state.algorithm === \"BFS\") && this.state.alreadyVisualized) {\r\n                this.instantNonAnimation();\r\n            }\r\n        } else if (this.state.movingEndNode) {\r\n            // console.log(\"Moving End Node\");\r\n            const newGrid = this.state.nodes.slice();\r\n            const currentNode = this.state.nodes[row][col];\r\n            const newNode = {\r\n                ...currentNode,\r\n                isFinish: true\r\n            };\r\n            const oldEndNode = this.state.nodes[previousEndNode[0]][previousEndNode[1]];\r\n            const oldNoLongerEndNode = {\r\n                ...oldEndNode,\r\n                isFinish: false,\r\n            };\r\n            newGrid[row][col] = newNode;\r\n            newGrid[previousEndNode[0]][previousEndNode[1]] = oldNoLongerEndNode;\r\n            this.setState({nodes:newGrid, currentEndNode:[newNode.row, newNode.col], previousEndNode: [newNode.row, newNode.col]});\r\n            this.clearBoard();\r\n            // console.log(\"end node instant animation \");\r\n            if ((this.state.algorithm === \"Djikstra\" || this.state.algorithm === \"AStar\") && this.state.alreadyVisualized) {\r\n                setTimeout(() => {\r\n                    // this.clearBoard();\r\n                    this.instantAnimationWithShortestPath();\r\n                }, 0)\r\n            } else if ((this.state.algorithm === \"DFS\" || this.state.algorithm === \"BFS\") && this.state.alreadyVisualized) {\r\n                this.instantNonAnimation();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    handleMouseEnter(row,col) {\r\n        // console.log(\"MousePressed \" + this.state.mousePressed);\r\n        if (!this.state.mousePressed) return;\r\n        if (!this.state.addingWeight) {\r\n            const newGrid = this.makeNewGridWithWall(row, col);\r\n            this.setState({nodes:newGrid});\r\n        }\r\n        else {\r\n            if (this.state.algorithm === \"Djikstra\") {\r\n                const newGrid = this.makeNewGridWithWeight(row, col);\r\n                this.setState({nodes: newGrid});\r\n            }\r\n        }\r\n    }\r\n\r\n    makeNewGridWithWeight(row,col) {\r\n        const newGrid = this.state.nodes.slice();\r\n        const currentNode = this.state.nodes[row][col];\r\n        if (!currentNode.isWall) {\r\n            const newNode = {\r\n                ...currentNode,\r\n                nodeWeight: currentNode.nodeWeight === 1 ? 10: 1\r\n            };\r\n            newGrid[row][col] = newNode;\r\n        }\r\n        return newGrid;\r\n    }\r\n\r\n    // This function is used to make 'walls' in the grid\r\n    makeNewGridWithWall(row,col) {\r\n        const newGrid = this.state.nodes.slice();\r\n        const currentNode = this.state.nodes[row][col];\r\n        const newNode = {\r\n            ...currentNode,\r\n            isWall: !currentNode['isWall']\r\n        };\r\n        newGrid[row][col] = newNode;\r\n        return newGrid;\r\n    }\r\n\r\n    // Determine if there is a path from start to end via BFS\r\n    visualizeBFS() {\r\n        const {nodes, currentStartNode, currentEndNode} = this.state;\r\n        const startNode = nodes[currentStartNode[0]][currentStartNode[1]];\r\n        const endNode = nodes[currentEndNode[0]][currentEndNode[1]];\r\n        const visitedNode = BFS(nodes, startNode, endNode);\r\n        this.animate(visitedNode);\r\n        setTimeout( () => {\r\n            this.setState({alreadyVisualized:true});\r\n        }, TIME_OUT_CONST * (visitedNode.length + 10)\r\n        )\r\n    }\r\n\r\n    // Determine if there is a path from start to end via DFS\r\n    visualizeDFS() {\r\n        const {nodes, currentStartNode, currentEndNode} = this.state;\r\n        const startNode = nodes[currentStartNode[0]][currentStartNode[1]];\r\n        const endNode = nodes[currentEndNode[0]][currentEndNode[1]];\r\n        const visitedNode = DFS(nodes, startNode, endNode);\r\n        this.animate(visitedNode);\r\n        setTimeout( () => {\r\n            this.setState({alreadyVisualized:true});\r\n        }, TIME_OUT_CONST * (visitedNode.length + 10)\r\n        )\r\n    }\r\n\r\n    //This function will find the shortest path from start to end via Djikstra\r\n    visualizeDjikstra() {\r\n        const {nodes,initialAnimationFinished,currentStartNode, currentEndNode} = this.state;\r\n        const startNode = nodes[currentStartNode[0]][currentStartNode[1]];\r\n        const endNode = nodes[currentEndNode[0]][currentEndNode[1]];\r\n        const visitedNode = Dijkstra(nodes,startNode,endNode);\r\n        // const visitedNode = AStar(nodes, startNode, endNode);\r\n        const beforeTimeStartInterval = this.animate(visitedNode) + 35;\r\n        this.setState({inAnimation: true});\r\n        var shortestPath = constructShortestPath(nodes, startNode, endNode);\r\n        if (shortestPath === \"No path exist\") {\r\n            console.log(\"No path exist\");\r\n            return;\r\n        }\r\n        shortestPath = shortestPath.reverse();\r\n        console.log(nodes);\r\n        this.animateShortestPath(shortestPath,beforeTimeStartInterval,true);\r\n        const setTimeoutAgainFk = shortestPath.length + beforeTimeStartInterval;\r\n        setTimeout(() => {\r\n            this.setState({alreadyVisualized: true, inAnimation:false})\r\n        }, TIME_OUT_CONST * (setTimeoutAgainFk + 50))\r\n    }\r\n\r\n    visualizeAStar() {\r\n        const {nodes,initialAnimationFinished,currentStartNode, currentEndNode} = this.state;\r\n        const startNode = nodes[currentStartNode[0]][currentStartNode[1]];\r\n        const endNode = nodes[currentEndNode[0]][currentEndNode[1]];\r\n        const visitedNode = AStar(nodes, startNode, endNode);\r\n        const beforeTimeStartInterval = this.animate(visitedNode) + 35;\r\n        this.setState({inAnimation: true});\r\n        var shortestPath = constructShortestPath(nodes, startNode, endNode);\r\n        if (shortestPath === \"No path exist\") {\r\n            console.log(\"No path exist\");\r\n            return;\r\n        }\r\n        shortestPath = shortestPath.reverse();\r\n        console.log(nodes);\r\n        this.animateShortestPath(shortestPath,beforeTimeStartInterval,true);\r\n        const setTimeoutAgainFk = shortestPath.length + beforeTimeStartInterval;\r\n        setTimeout(() => {\r\n            this.setState({alreadyVisualized: true, inAnimation:false})\r\n        }, TIME_OUT_CONST * (setTimeoutAgainFk + 50))\r\n    }\r\n\r\n    // visitedNode(List) = All of the nodes that makes the shortest path from start to end\r\n    // beforeTimeStartInterval(Integer) = How many nodes are visited before we found our end node\r\n    // shouldSetTimeout(Boolean) = determines if we should be using instant animation or not.\r\n    animateShortestPath(visitedNode, beforeTimeStartInterval, shouldSetTimeout) {\r\n        const newGrid = this.state.nodes.slice();\r\n        // this.setState({inAnimation:true});\r\n        // console.log(\"Setting shortest path inAnimation to true\");\r\n        if (shouldSetTimeout) {\r\n            for (let i = 0; i < visitedNode.length; i++) {\r\n                const node = visitedNode[i];\r\n                const newNode = {\r\n                    ...node,\r\n                    isShortestPathNode: true,\r\n                };\r\n                setTimeout(() => {\r\n                    newGrid[node.row][node.col] = newNode;\r\n                    this.setState({nodes: newGrid});\r\n                }, TIME_OUT_CONST * (i + beforeTimeStartInterval));\r\n            }\r\n        }\r\n    }\r\n\r\n    instantNonAnimation() {\r\n        const {nodes, currentStartNode, currentEndNode} = this.state;\r\n        const startNode = nodes[currentStartNode[0]][currentStartNode[1]];\r\n        const endNode = nodes[currentEndNode[0]][currentEndNode[1]];\r\n        let visitedNode;\r\n        if (this.state.algorithm === \"BFS\") {\r\n            visitedNode = BFS(nodes, startNode, endNode);\r\n        } else if (this.state.algorithm === \"DFS\") {\r\n            visitedNode = DFS(nodes, startNode, endNode);\r\n        }\r\n        const newGrid = this.state.nodes.slice();\r\n        for (let i =0; i < visitedNode.length; i++) {\r\n            const node = visitedNode[i];\r\n            const currentFinalNode = this.state.currentEndNode;\r\n            if (node['nodeWeight'] === 1) {\r\n                const newNode = {\r\n                    ...node,\r\n                    isAnimated: true,\r\n                };\r\n                newGrid[node.row][node.col] = newNode;\r\n            }\r\n        }\r\n        this.setState({nodes:newGrid});\r\n    }\r\n\r\n    animate(visitedNode) {\r\n        this.setState({inAnimation:true});\r\n        // console.log(visitedNode.length);\r\n        for (let i =0; i < visitedNode.length; i++) {\r\n            const node = visitedNode[i];\r\n            const currentFinalNode = this.state.currentEndNode;\r\n            if (node.row === currentFinalNode[0] && node.col === currentFinalNode[1]) {\r\n                setTimeout(() => {\r\n                    this.setState({inAnimation:false});\r\n                }, (i+20)*TIME_OUT_CONST);\r\n                return i;\r\n            }\r\n            if (node['nodeWeight'] === 1) {\r\n                setTimeout(() => {\r\n                        const newGrid = this.state.nodes.slice();\r\n                        const newNode = {\r\n                            ...node,\r\n                            isAnimated: true,\r\n                        };\r\n                        newGrid[node.row][node.col] = newNode;\r\n                        this.setState({nodes: newGrid})\r\n                    },\r\n                    TIME_OUT_CONST * i);\r\n            }\r\n        }\r\n    }\r\n\r\n    instantAnimationWithShortestPath() {\r\n        const {nodes,initialAnimationFinished,currentStartNode, currentEndNode, algorithm} = this.state;\r\n        const startNode = nodes[currentStartNode[0]][currentStartNode[1]];\r\n        const endNode = nodes[currentEndNode[0]][currentEndNode[1]];\r\n        var visitedNode;\r\n        if (algorithm === \"Djikstra\") {\r\n            visitedNode = Dijkstra(nodes, startNode, endNode);\r\n        } else if (algorithm ===\"AStar\") {\r\n            visitedNode = AStar(nodes,startNode, endNode);\r\n        }\r\n        const newGrid = this.state.nodes.slice();\r\n        for (let i =0; i < visitedNode.length; i++) {\r\n            const node = visitedNode[i];\r\n            const currentFinalNode = this.state.currentEndNode;\r\n            if (node.row === currentFinalNode[0] && node.col === currentFinalNode[1]) {\r\n                break;\r\n            }\r\n            const newNode = {\r\n                ...node,\r\n                isAnimated: true,\r\n            };\r\n            newGrid[node.row][node.col] = newNode;\r\n        }\r\n        // console.log(\"Before shortest path\");\r\n        var shortestPath = constructShortestPath(nodes, startNode, endNode);\r\n        if (shortestPath === \"No path exist\") {\r\n            console.log(\"No path exist\");\r\n            return;\r\n        }\r\n        shortestPath = shortestPath.reverse();\r\n        for (let i = 0; i < shortestPath.length; i++) {\r\n            const node = shortestPath[i];\r\n            const newNode = {\r\n                ...node,\r\n                isShortestPathNode: true,\r\n            };\r\n            newGrid[newNode.row][newNode.col] = newNode;\r\n        };\r\n        this.setState({nodes:newGrid});\r\n    }\r\n\r\n    clearBoard(resetAlreadyVisualized) {\r\n        const {nodes,currentStartNode,currentEndNode, inAnimation} = this.state;\r\n        const newGrid = this.state.nodes.slice();\r\n        if (!inAnimation) {\r\n            for (var row = 0; row < nodes.length; row++) {\r\n                const column = nodes[row];\r\n                for (var col = 0; col < column.length; col++) {\r\n                    var currentNode = column[col];\r\n                    if (currentNode['isStart']) {\r\n                        // currentNode['isWall'] = false;\r\n                        currentNode['isAnimated'] = false;\r\n                        currentNode['isVisited'] = false;\r\n                        currentNode['isShortestPathNode'] = false;\r\n                        currentNode['distance'] = 0;\r\n                        currentNode['distanceSum'] = 0;\r\n                        newGrid[row][col] = currentNode\r\n                    } else {\r\n                        // currentNode['isWall'] = false;\r\n                        currentNode['isAnimated'] = false;\r\n                        currentNode['isVisited'] = false;\r\n                        currentNode['isShortestPathNode'] = false;\r\n                        currentNode['distance'] = 99999999;\r\n                        currentNode['distanceSum'] = 99999999;\r\n                        newGrid[row][col] = currentNode\r\n                    }\r\n                }\r\n            }\r\n            console.log(\"After clearing board\");\r\n            // console.log(newGrid);\r\n            this.setState({nodes:newGrid});\r\n            if (resetAlreadyVisualized) {\r\n                this.setState({alreadyVisualized:false})\r\n            }\r\n        }\r\n    }\r\n\r\n    clearWall() {\r\n        const {nodes,inAnimation} = this.state;\r\n        if (!inAnimation) {\r\n            const newGrid = this.state.nodes.slice();\r\n            for (var row = 0; row < nodes.length; row++) {\r\n                const column = nodes[row];\r\n                for (var col = 0; col < column.length; col++) {\r\n                    var currentNode = column[col];\r\n                    currentNode['isWall'] = false;\r\n                    currentNode['nodeWeight'] = 1;\r\n                }\r\n            }\r\n            this.setState({nodes: newGrid})\r\n        }\r\n    }\r\n\r\n\r\n    visualizeAlgorithm() {\r\n        const {algorithm} = this.state;\r\n        this.clearBoard(true);\r\n        // this.setState({alreadyVisualized:false});\r\n        if (algorithm === \"BFS\") {\r\n            this.visualizeBFS();\r\n        } else if (algorithm === \"DFS\") {\r\n            this.visualizeDFS();\r\n        } else if (algorithm === \"Djikstra\") {\r\n            this.visualizeDjikstra()\r\n            // this.instantAnimationWithShortestPath();\r\n        } else if (algorithm === \"AStar\") {\r\n            this.visualizeAStar();\r\n        }\r\n    }\r\n\r\n    selectSpeed(event) {\r\n        if (event.target.value === \"Fast\") {\r\n            TIME_OUT_CONST = 20;\r\n        } else if (event.target.value === \"Average\") {\r\n            TIME_OUT_CONST = 50;\r\n        } else if (event.target.value === \"Slow\") {\r\n            TIME_OUT_CONST = 100;\r\n        }\r\n    }\r\n\r\n    selectAlgorithm(event) {\r\n        this.setState({algorithm: event.target.value});\r\n        this.clearBoard(true);\r\n    }\r\n\r\n    incrementCurrentSlide() {\r\n        // console.log(this.state.currentScale);\r\n        var currentVal = this.state.currentSlide;\r\n        currentVal += 1;\r\n        this.setState({currentSlide: currentVal});\r\n        // this.setState({currentSlide: this.state.currentSlide + 1 });\r\n        // console.log(this.state.currentSlide)\r\n    }\r\n\r\n    decrementCurrentSlide() {\r\n        var currentVal = this.state.currentSlide;\r\n        currentVal -= 1;\r\n        this.setState({currentSlide: currentVal});\r\n        // this.setState({currentSlide: this.state.currentSlide - 1 });\r\n        console.log()\r\n    }\r\n\r\n    generateNextSectionButtons() {\r\n        return (\r\n            <div className='backOrNextSection'>\r\n                <Button className='backButton' onClick={() => this.decrementCurrentSlide()}>\r\n                    Back\r\n                </Button>\r\n                <Button className='nextButton' onClick={() => this.incrementCurrentSlide()}>\r\n                    Next\r\n                </Button>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    initialTutorialSlideShow() {\r\n        var chosenSlide = this.state.currentSlide;\r\n        if (chosenSlide === 0 ) {\r\n            return (\r\n                <div className=\"tutorial\">\r\n                    Welcome to my pathfinding visualizer.<br></br>\r\n                    This was a side project inspired by Clement Mihailescu's pathfinding visualizer. <br></br>\r\n                    The goal is to show how the algorithm make their decision to reach the end point through visualization. <br></br>\r\n                    Press next to begin the tutorial on how to navigate this visualizer. <br></br>\r\n                    Click anywhere outside the modal to exit the tutorial and begin visualizing!\r\n                    {this.generateNextSectionButtons()}\r\n                    {/*I used this project as an opportunity to learn reactJS, front-end development and learn more about algorithms.*/}\r\n                    {/*Welcome to my pathfinding visualizer. This was a side project inspired by Clement Mihailescu's pathfinding visualizer.*/}\r\n                    {/*/!*The goal is to show what path the algorithms take before reaching their destination*!/*/}\r\n                    {/*<Button className='skipButton'>*/}\r\n                        {/*Skip*/}\r\n                    {/*</Button>*/}\r\n                </div>\r\n            )\r\n        } else if (chosenSlide === 1) {\r\n            return (\r\n            <div className='tutorial'>\r\n                <div className='tutorialButtonContainer'>\r\n                    <Button className=\"button tutorialMenu\">\r\n                        Visualize BFS\r\n                    </Button>\r\n                        Visualize BFS is used to start the path finding animation\r\n                    <br></br>\r\n                    <Button className=\"button tutorialMenu\">\r\n                        Clear Board\r\n                    </Button>\r\n                        Clear Board is used to reset the board to its initial state(no walls/no weights)\r\n                    <br></br>\r\n                    <Button className=\"button tutorialMenu\">\r\n                        Clear Wall\r\n                    </Button>\r\n                        Clear Wall is used to clear all the walls that were created\r\n                    <br></br>\r\n                    <Button className=\"button tutorialMenu\">\r\n                        Add Weight\r\n                    </Button>\r\n                        Add weight is used to add weight to a specific node\r\n                    <br></br>\r\n                    <Button className=\"button tutorialMenu\">\r\n                        BFS\r\n                    </Button>\r\n                        The BFS dropdown menu is used to select which algorithm to visualize\r\n                    <br></br>\r\n                    <Button className=\"button tutorialMenu\">\r\n                        Speed:\r\n                    </Button>\r\n                        The speed dropdown menu is used to select how fast you want the algorithm to run\r\n                    <br></br>\r\n                </div>\r\n                {this.generateNextSectionButtons()}\r\n            </div>\r\n            )\r\n        } else if (chosenSlide == 2) {\r\n            return (\r\n                <div className='tutorial'>\r\n                    Walls can be made by clicking on any node and then dragging it across the grid as shown in the video below.\r\n                    <br></br>\r\n                    {/*<video controls autoPlay={true} loop={true}>*/}\r\n                        {/*<source src={\"src/traffic.mp4\"} type={\"video/mp4\"}>*/}\r\n                        {/*</source>*/}\r\n                    {/*</video>*/}\r\n                    {/*<iframe width={200} height={200} src=\"https://www.youtube.com/watch?v=K79n-yRmTR0\">*/}\r\n                    {/*</iframe>*/}\r\n                    {/*<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/sLAO2QartWk\" frameBorder=\"0\"*/}\r\n                            {/*allow=\"accelerometer; autoplay=enabled; encrypted-media; gyroscope; picture-in-picture\"*/}\r\n                            {/*allowFullScreen>*/}\r\n                    {/*</iframe>*/}\r\n                    <img src={wallCreation}>\r\n                    </img>\r\n                    {/*<img src={\"src/PathFindingVisualizer/Resources/WallCreation.gif\"}>*/}\r\n                    {/*</img>*/}\r\n                    {this.generateNextSectionButtons()}\r\n                </div>\r\n            )\r\n        }\r\n    }\r\n\r\n    render() {\r\n        console.log(this.state.currentSlide);\r\n        const {nodes, mousePressed,algorithm, alreadyVisualized, addingWeight} = this.state;\r\n        var message = \"Add Weight\";\r\n        if (addingWeight) {\r\n            message = \"Stop Adding Weight\";\r\n        }\r\n        return (\r\n            <div className =\"outerContainer\">\r\n                {/*<Popup className={'popupSizing'}*/}\r\n                    {/*modal={true}*/}\r\n                    {/*defaultOpen={true}*/}\r\n                       {/*position = \"center center\"*/}\r\n                {/*>*/}\r\n                    {/*{this.initialTutorialSlideShow()}*/}\r\n                {/*</Popup>*/}\r\n                <Tutorial>\r\n                </Tutorial>\r\n                <nav className=\"navbar navbar-expand-lg navbar-light bg-light centerNavbar\">\r\n                    <Button className=\"button\" onClick={() => this.visualizeAlgorithm()}>\r\n                        Visualize {algorithm}\r\n                    </Button>\r\n                    <Button className=\"button\" onClick={() => this.clearBoard(true)}>\r\n                        Clear Board\r\n                    </Button>\r\n                    <Button className=\"button\" onClick={() => this.clearWall()}>\r\n                        Clear Wall\r\n                    </Button>\r\n                    <Button className=\"button\" onClick={() => this.setAddingWeight()}>\r\n                        {message}\r\n                    </Button>\r\n                    <Button className=\"button\">\r\n                        <div className =\"dropdown\">\r\n                            <select className =\"AlgorithmSelect\" onChange={this.selectAlgorithm}>\r\n                                <option value=\"BFS\"> BFS</option>\r\n                                <option value=\"DFS\"> DFS</option>\r\n                                <option value=\"Djikstra\"> Djikstra </option>\r\n                                <option value=\"AStar\"> A* </option>\r\n                            </select>\r\n                        </div>\r\n                    </Button>\r\n                    <Button className=\"button\">\r\n                        <div className =\"dropdown\">\r\n                            Speed:\r\n                            <select className = \"AlgorithmSelect\" onChange = {this.selectSpeed} >\r\n                                <option value=\"Fast\"> Fast </option>\r\n                                <option value=\"Slow\"> Slow </option>\r\n                                <option value=\"Average\"> Average </option>\r\n                            </select>\r\n                        </div>\r\n                    </Button>\r\n                </nav>\r\n                <div className = \"iconListDiv\">\r\n                    <ul className=\"iconList\">\r\n                        <li className=\"iconList\">\r\n                            <div className='box startNode'>\r\n                            </div>\r\n                            Start Node\r\n                        </li>\r\n                        <li className=\"iconList\">\r\n                            <div className='box endNode'>\r\n                            </div>\r\n                            End Node\r\n                        </li>\r\n                        <li className=\"iconList\">\r\n                            <div className='box'>\r\n                            </div>\r\n                            Unvisited Node\r\n                        </li>\r\n                        <li className=\"iconList\">\r\n                            <div className='box visitedNode'>\r\n                            </div>\r\n                            Visited Node\r\n                        </li>\r\n                        <li className=\"iconList\">\r\n                            <div className='box Wall'>\r\n                            </div>\r\n                            Wall\r\n                        </li>\r\n                        <li className=\"iconList\">\r\n                            <div className='box weightedNode'>\r\n                            </div>\r\n                            Weighted Node\r\n                        </li>\r\n                    </ul>\r\n                </div>\r\n                <div className=\"grid\">\r\n                {nodes.map((row, rowIdx) => {\r\n                    return (\r\n                        <div key={rowIdx} className={`row-${rowIdx}`}>\r\n                            {row.map((node, nodeIdx) => {\r\n                                const {isStart, isFinish,isAnimated, row, col,isWall, isShortestPathNode,nodeWeight} = node;\r\n                                return (\r\n                                    <Node\r\n                                        key={nodeIdx}\r\n                                        isStart = {isStart}\r\n                                        isFinish = {isFinish}\r\n                                        isAnimated = {isAnimated}\r\n                                        isWall = {isWall}\r\n                                        isShortestPathNode = {isShortestPathNode}\r\n                                        onMouseDown={(row,col) => this.handleMouseDown(row,col)}\r\n                                        onMouseEnter={(row,col) => this.handleMouseEnter(row,col)}\r\n                                        mousePressed ={mousePressed}\r\n                                        onMouseUp= {() => this.handleMouseUp(row,col)}\r\n                                        onMouseOver={ () => this.handleMouseOver(row,col)}\r\n                                        row={row}\r\n                                        col={col}\r\n                                        instantAnimation = {alreadyVisualized}\r\n                                        nodeWeight = {nodeWeight}\r\n                                    >\r\n                                    </Node>\r\n                                );\r\n                            })}\r\n                    </div>\r\n                    );\r\n                })}\r\n            </div>\r\n        </div>);\r\n    }\r\n}\r\n","import React from 'react';\nimport './App.css';\nimport Path from './PathFindingVisualizer/Path';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Path></Path>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { BrowserRouter as Router } from 'react-router-dom';\nimport '../node_modules/bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(<Router basename={process.env.PUBLIC_URL}>< App /></Router>, document.getElementById('root'));\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}