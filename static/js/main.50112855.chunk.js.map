{"version":3,"sources":["PathFindingVisualizer/Node/Node.jsx","PathFindingVisualizer/Algorithms/Djikstra.js","PathFindingVisualizer/Path.jsx","PathFindingVisualizer/Algorithms/BFS.js","PathFindingVisualizer/Algorithms/DFS.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","state","this","isFinish","isStart","isAnimated","row","col","isWall","onMouseDown","onMouseEnter","onMouseUp","isShortestPathNode","instantAnimation","onMouseOver","extraClassName","id","className","Component","Dijkstra","grid","startNode","endNode","queueOfVisited","visitedInOrder","push","length","currentNode","shift","currentRow","currentCol","nextDistance","aboveNode","aboveNodeDistance","belowNode","belowNodeDistance","leftNode","leftNodeDistance","rightNode","rightNodeDistance","constructShortestPath","StartNode","startRow","startCol","visitedStack","previousNodeCoords","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","Path","prop","nodes","mousePressed","algorithm","movingStartNode","previousStartNode","movingEndNode","previousEndNode","currentStartNode","currentEndNode","alreadyVisualized","selectAlgorithm","bind","visualizeDFS","visualizeBFS","nodeObject","isTop","isBottom","GRID_ROW_LENGTH","isLeft","isRight","GRID_COL_LENGTH","isVisited","distance","previous","setState","newGrid","slice","newNode","oldNoLongerStartNode","console","log","clearBoard","setTimeout","instantAnimationWithShortestPath","oldNoLongerEndNode","makeNewGridWithWall","visitedNode","endRow","endCol","BFS","animate","stack","returnVisitedStack","pop","topNode","bottomNode","DFS","initialAnimationFinished","beforeTimeStartInterval","shortestPath","reverse","animateShortestPath","setTimeoutAgainFk","shouldSetTimeout","i","node","currentFinalNode","resetAlreadyVisualized","column","visualizeDjikstra","event","target","value","Button","onClick","visualizeAlgorithm","clearWall","onChange","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","handleMouseOver","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.50112855.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n    render() {\r\n        const {isFinish,\r\n            isStart,\r\n            isAnimated,\r\n            row,\r\n            col,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            isShortestPathNode,\r\n            instantAnimation,\r\n            onMouseOver,\r\n        } = this.props;\r\n        var extraClassName = isFinish ? 'node-finish':\r\n            isStart ? 'node-start':\r\n            isShortestPathNode ? 'node-shortest-path':\r\n            isAnimated ? 'node-visited':\r\n            isWall ? 'node-wall':\r\n            '';\r\n        if (instantAnimation && !isStart && !isFinish) {\r\n            if (extraClassName === \"node-shortest-path\" || extraClassName === \"node-visited\") {\r\n                extraClassName += \"-instant-animation\"\r\n            }\r\n        }\r\n        return <div\r\n            id = {`node-${row}-${col}`}\r\n            className={`node ${extraClassName}`}\r\n            onMouseDown ={() => onMouseDown(row,col)}\r\n            onMouseEnter ={() => onMouseEnter(row,col)}\r\n            onMouseOver = {() => onMouseOver(row,col)}\r\n            onMouseUp = {() => onMouseUp(row,col)}>\r\n        </div>;\r\n    }\r\n}\r\n\r\nexport const DEFAULT_NODE = {\r\n    row: 0,\r\n    col: 0,\r\n};\r\n\r\n","export function Dijkstra(grid, startNode, endNode) {\n    const {row,col} = startNode;\n    const endRow = endNode['row'];\n    const endCol = endNode['col'];\n    const queueOfVisited = [];\n    // console.log(grid);\n    const visitedInOrder = [];\n    if (grid != null && startNode != null) {\n        queueOfVisited.push(startNode);\n    }\n    while (queueOfVisited.length > 0) {\n        const currentNode = queueOfVisited.shift();\n        visitedInOrder.push(currentNode);\n        // console.log(\"Current Node is [\"+ currentNode.row + ',' + currentNode.col + ']');\n        if (!currentNode['isVisited']) {\n            const currentRow = currentNode['row'];\n            const currentCol = currentNode['col'];\n            const currentDistance = currentNode['distance'];\n            // console.log(\"Current Distance Is \" + currentDistance);\n            var nextDistance = currentDistance + 1;\n            // if (currentRow === row && currentCol === col) {\n            //     console.log(\"Current Distance Is \" + currentDistance);\n            //     console.log(\"Next distance is\" + nextDistance);\n            // }\n            if (currentNode['isTop'] === false) {\n                const aboveNode = grid[currentRow - 1][currentCol];\n                if (aboveNode['isVisited'] === false && !aboveNode['isWall']) {\n                    queueOfVisited.push(aboveNode);\n                    const aboveNodeDistance = aboveNode['distance'];\n                    if (aboveNodeDistance === \"infinity\" || nextDistance < aboveNodeDistance) {\n                        aboveNode['distance'] = nextDistance;\n                        aboveNode['previous'] = [currentRow, currentCol];\n                    }\n                }\n            }\n            if (currentNode['isBottom'] === false) {\n                const belowNode = grid[currentRow + 1][currentCol];\n                if (belowNode['isVisited'] === false && !belowNode['isWall']) {\n                    queueOfVisited.push(belowNode);\n                    const belowNodeDistance = belowNode['distance'];\n                    if (belowNodeDistance === \"infinity\" || nextDistance < belowNodeDistance) {\n                        belowNode['distance'] = nextDistance;\n                        belowNode['previous'] = [currentRow, currentCol];\n                    }\n                }\n            }\n            if (currentNode['isLeft'] === false) {\n                const leftNode = grid[currentRow][currentCol - 1];\n                if (leftNode['isVisited'] === false && !leftNode['isWall']) {\n                    queueOfVisited.push(leftNode);\n                    const leftNodeDistance = leftNode['distance'];\n                    if (leftNodeDistance === \"infinity\" || nextDistance < leftNodeDistance) {\n                        leftNode['distance'] = nextDistance;\n                        leftNode['previous'] = [currentRow, currentCol];\n                    }\n                }\n            }\n            if (currentNode['isRight'] === false) {\n                const rightNode = grid[currentRow][currentCol + 1];\n                if (rightNode['isVisited'] === false && !rightNode['isWall']) {\n                    queueOfVisited.push(rightNode);\n                    const rightNodeDistance = rightNode['distance'];\n                    if (rightNodeDistance === \"infinity\" || nextDistance < rightNodeDistance) {\n                        rightNode['distance'] = nextDistance;\n                        rightNode['previous'] = [currentRow, currentCol];\n                    }\n                }\n            }\n            // if (currentNode.row === row && currentNode.col === col) {\n            //     const rightNode = grid[currentRow][currentCol + 1];\n            //     const leftNode = grid[currentRow][currentCol - 1];\n            //     const topNode = grid[currentRow-1][currentCol];\n            //     const belowNode = grid[currentRow+1][currentCol];\n            //     console.log(\"Right Node distance =\" + rightNode.distance);\n            //     console.log(\"Left Node distance =\" + leftNode.distance);\n            //     console.log(\"Top node distance = \" + topNode.distance);\n            //     console.log(\"Below node distance = \" + belowNode.distance);\n            // }\n            currentNode['isVisited'] = true;\n        }\n    }\n        // console.log(grid);\n    return visitedInOrder;\n}\n\nexport function constructShortestPath(grid,StartNode,endNode) {\n    const startRow = StartNode['row'];\n    const startCol = StartNode['col'];\n    var currentNode = endNode;\n    var visitedStack = [];\n    while (currentNode != null) {\n        // console.log(\"Current Node\" + currentNode.row + ',' + currentNode.col);\n        // console.log(\"Current node distance is \" + currentNode.distance);\n        // console.log(\"Current Node Previous is\" + currentNode['previous']);\n        if (currentNode['distance'] === \"infinity\") {\n            return \"No path exist\";\n        } else {\n            const currentRow = currentNode['row'];\n            const currentCol = currentNode['col'];\n            // console.log(\"StartNode value is \" + startRow + ',' + startCol);\n            if (currentRow === startRow && currentCol === startCol) {\n                return visitedStack;\n            } else {\n                const previousNodeCoords = currentNode['previous'];\n                // console.log(\"previousNodeCoords = \" + previousNodeCoords[0] + \",\" + previousNodeCoords[1]);\n                currentNode = grid[previousNodeCoords[0]][previousNodeCoords[1]]\n            }\n            visitedStack.push(currentNode);\n        }\n    }\n    return visitedStack;\n}","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\n\r\nimport './Path.css'\r\nimport {BFS} from './Algorithms/BFS';\r\nimport {DFS} from \"./Algorithms/DFS\";\r\nimport {constructShortestPath, Dijkstra} from \"./Algorithms/Djikstra\"\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport {Button} from 'react-bootstrap';\r\n\r\nconst START_NODE_ROW = 3;\r\nconst START_NODE_COL = 5;\r\nconst FINISH_NODE_ROW = 5;\r\nconst FINISH_NODE_COL = 5;\r\nconst GRID_ROW_LENGTH = 20;\r\nconst GRID_COL_LENGTH = 50;\r\nconst TIME_OUT_CONST = 65;\r\n\r\nexport default class Path extends Component {\r\n    constructor(prop) {\r\n        super(prop);\r\n        this.state = {\r\n            nodes: [],\r\n            mousePressed: false,\r\n            algorithm: \"BFS\",\r\n            movingStartNode: false,\r\n            previousStartNode: [START_NODE_ROW, START_NODE_COL],\r\n            movingEndNode: false,\r\n            previousEndNode: [FINISH_NODE_ROW, FINISH_NODE_COL],\r\n            currentStartNode: [START_NODE_ROW, START_NODE_COL],\r\n            currentEndNode: [FINISH_NODE_ROW, FINISH_NODE_COL],\r\n            alreadyVisualized: false,\r\n        };\r\n        this.selectAlgorithm = this.selectAlgorithm.bind(this);\r\n        this.visualizeDFS = this.visualizeDFS.bind(this);\r\n        this.visualizeBFS = this.visualizeBFS.bind(this);\r\n    }\r\n\r\n    componentDidMount() {\r\n        const {currentStartNode, currentEndNode} = this.state;\r\n        const nodes = [];\r\n        for (let row = 0; row < GRID_ROW_LENGTH; row++) {\r\n            const currentRow = [];\r\n            for (let col = 0; col < GRID_COL_LENGTH; col++) {\r\n                const nodeObject = {\r\n                    row,\r\n                    col,\r\n                    isStart: row === currentStartNode[0] && col === currentStartNode[1],\r\n                    isFinish: row === currentEndNode[0] && col === currentEndNode[1],\r\n                    isTop: row === 0,\r\n                    isBottom: row === GRID_ROW_LENGTH-1,\r\n                    isLeft: col === 0,\r\n                    isRight: col === GRID_COL_LENGTH-1,\r\n                    isVisited: false,\r\n                    isAnimated: false,\r\n                    isWall: false,\r\n                    distance: row === currentStartNode[0] && col === currentStartNode[1] ? 0 : \"infinity\",\r\n                    previous : [null,null],\r\n                    isShortestPathNode: false,\r\n                    instantAnimation: false\r\n                };\r\n                currentRow.push(nodeObject)\r\n            }\r\n            nodes.push(currentRow)\r\n        }\r\n        // console.log(nodes);\r\n        this.setState({nodes});\r\n    }\r\n\r\n    handleMouseDown(row,col) {\r\n        const mousePressed = this.state.mousePressed;\r\n        if (this.state.nodes[row][col].isStart) {\r\n            // console.log(\"Start Node Move\");\r\n            this.setState({movingStartNode:true, previousStartNode: [row,col]});\r\n            return;\r\n        } else if (this.state.nodes[row][col].isFinish) {\r\n            // console.log(\"End Node Move\");\r\n            this.setState({movingEndNode:true, previousEndNode: [row,col]});\r\n            return;\r\n        }\r\n        this.setState({mousePressed: !mousePressed});\r\n    }\r\n\r\n    handleMouseUp(row,col) {\r\n        // console.log(\"Handle Mouse Up\");\r\n        const {previousStartNode, previousEndNode} = this.state;\r\n        // if (this.state.movingStartNode) {\r\n        //     // console.log(\"Moving start Node\");\r\n        //     const newGrid = this.state.nodes.slice();\r\n        //     const currentNode = this.state.nodes[row][col];\r\n        //     const newNode = {\r\n        //         ...currentNode,\r\n        //         isStart: true,\r\n        //         distance: 0,\r\n        //     };\r\n        //     const oldStartNode = this.state.nodes[previousStartNode[0]][previousStartNode[1]];\r\n        //     const oldNoLongerStartNode = {\r\n        //         ...oldStartNode,\r\n        //         isStart: false,\r\n        //         distance: \"infinity\",\r\n        //     };\r\n        //     newGrid[row][col] = newNode;\r\n        //     newGrid[previousStartNode[0]][previousStartNode[1]] = oldNoLongerStartNode;\r\n        //     this.setState({nodes:newGrid, currentStartNode: [newNode.row,newNode.col]});\r\n        //     this.clearBoard();\r\n        //\r\n        //     console.log(\"Start node instant animation\");\r\n        //     // console.log(\"Current algorithm is\" + this.state.algorithm + \" alreadyVisualized = \" + this.state.alreadyVisualized);\r\n        //     if (this.state.algorithm === \"Djikstra\" && this.state.alreadyVisualized) {\r\n        //         setTimeout(() => {\r\n        //             this.instantAnimationWithShortestPath();\r\n        //         }, 0)\r\n        //     }\r\n        // }\r\n        // else\r\n        //     if (this.state.movingEndNode) {\r\n        //     // console.log(\"Moving End Node\");\r\n        //     const newGrid = this.state.nodes.slice();\r\n        //     const currentNode = this.state.nodes[row][col];\r\n        //     const newNode = {\r\n        //         ...currentNode,\r\n        //         isFinish: true\r\n        //     };\r\n        //     const oldEndNode = this.state.nodes[previousEndNode[0]][previousEndNode[1]];\r\n        //     const oldNoLongerEndNode = {\r\n        //         ...oldEndNode,\r\n        //         isFinish: false,\r\n        //     };\r\n        //     newGrid[row][col] = newNode;\r\n        //     newGrid[previousEndNode[0]][previousEndNode[1]] = oldNoLongerEndNode;\r\n        //     this.setState({nodes:newGrid, currentEndNode:[newNode.row, newNode.col]});\r\n        //     this.clearBoard();\r\n        //     // console.log(\"end node instant animation \");\r\n        //     // if (this.state.algorithm === \"Djikstra\" && this.state.alreadyVisualized) {\r\n        //     //     this.instantAnimationWithShortestPath();\r\n        //     // }\r\n        // }\r\n        this.setState({mousePressed:false, movingStartNode:false, movingEndNode:false});\r\n    }\r\n\r\n    handleMouseOver(row,col) {\r\n        const {previousStartNode, previousEndNode} = this.state;\r\n        if (this.state.movingStartNode) {\r\n            // console.log(\"Moving start Node\");\r\n            const newGrid = this.state.nodes.slice();\r\n            const currentNode = this.state.nodes[row][col];\r\n            const newNode = {\r\n                ...currentNode,\r\n                isStart: true,\r\n                distance: 0,\r\n            };\r\n            const oldStartNode = this.state.nodes[previousStartNode[0]][previousStartNode[1]];\r\n            const oldNoLongerStartNode = {\r\n                ...oldStartNode,\r\n                isStart: false,\r\n                distance: \"infinity\",\r\n            };\r\n            newGrid[row][col] = newNode;\r\n            newGrid[previousStartNode[0]][previousStartNode[1]] = oldNoLongerStartNode;\r\n            console.log(\"Previous start node = \" + oldNoLongerStartNode.row + \",\" + oldNoLongerStartNode.col + \" and isStart =\" + oldNoLongerStartNode.isStart);\r\n            console.log(\"After setting previous start node to nothing\");\r\n            console.log(newGrid);\r\n            this.setState({nodes:newGrid, currentStartNode: [newNode.row,newNode.col], previousStartNode:[newNode.row, newNode.col]});\r\n            this.clearBoard();\r\n\r\n            // console.log(\"Start node instant animation\");\r\n            // console.log(\"Current algorithm is\" + this.state.algorithm + \" alreadyVisualized = \" + this.state.alreadyVisualized);\r\n            if (this.state.algorithm === \"Djikstra\" && this.state.alreadyVisualized) {\r\n                setTimeout(() => {\r\n                    // this.clearBoard();\r\n                    this.instantAnimationWithShortestPath();\r\n                }, 0)\r\n            }\r\n        } else if (this.state.movingEndNode) {\r\n            // console.log(\"Moving End Node\");\r\n            const newGrid = this.state.nodes.slice();\r\n            const currentNode = this.state.nodes[row][col];\r\n            const newNode = {\r\n                ...currentNode,\r\n                isFinish: true\r\n            };\r\n            const oldEndNode = this.state.nodes[previousEndNode[0]][previousEndNode[1]];\r\n            const oldNoLongerEndNode = {\r\n                ...oldEndNode,\r\n                isFinish: false,\r\n            };\r\n            newGrid[row][col] = newNode;\r\n            newGrid[previousEndNode[0]][previousEndNode[1]] = oldNoLongerEndNode;\r\n            this.setState({nodes:newGrid, currentEndNode:[newNode.row, newNode.col], previousEndNode: [newNode.row, newNode.col]});\r\n            this.clearBoard();\r\n            // console.log(\"end node instant animation \");\r\n            if (this.state.algorithm === \"Djikstra\" && this.state.alreadyVisualized) {\r\n                setTimeout(() => {\r\n                    // this.clearBoard();\r\n                    this.instantAnimationWithShortestPath();\r\n                }, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    handleMouseEnter(row,col) {\r\n        // console.log(\"MousePressed \" + this.state.mousePressed);\r\n        if (!this.state.mousePressed) return;\r\n        const newGrid = this.makeNewGridWithWall(row,col);\r\n        this.setState({nodes:newGrid});\r\n    }\r\n\r\n    // This function is used to make 'walls' in the grid\r\n    makeNewGridWithWall(row,col) {\r\n        const newGrid = this.state.nodes.slice();\r\n        const currentNode = this.state.nodes[row][col];\r\n        const newNode = {\r\n            ...currentNode,\r\n            isWall: !currentNode['isWall']\r\n        };\r\n        newGrid[row][col] = newNode;\r\n        return newGrid;\r\n    }\r\n\r\n    // Determine if there is a path from start to end via BFS\r\n    visualizeBFS() {\r\n        const {nodes, currentStartNode, currentEndNode} = this.state;\r\n        const startNode = nodes[currentStartNode[0]][currentStartNode[1]];\r\n        const endNode = nodes[currentEndNode[0]][currentEndNode[1]];\r\n        const visitedNode = BFS(nodes, startNode, endNode);\r\n        this.animate(visitedNode);\r\n    }\r\n\r\n    // Determine if there is a path from start to end via DFS\r\n    visualizeDFS() {\r\n        const {nodes, currentStartNode, currentEndNode} = this.state;\r\n        const startNode = nodes[currentStartNode[0]][currentStartNode[1]];\r\n        const endNode = nodes[currentEndNode[0]][currentEndNode[1]];\r\n        const visitedNode = DFS(nodes, startNode, endNode);\r\n        this.animate(visitedNode);\r\n    }\r\n\r\n    //This function will find the shortest path from start to end via Djikstra\r\n    visualizeDjikstra() {\r\n        const {nodes,initialAnimationFinished,currentStartNode, currentEndNode} = this.state;\r\n        const startNode = nodes[currentStartNode[0]][currentStartNode[1]];\r\n        const endNode = nodes[currentEndNode[0]][currentEndNode[1]];\r\n        const visitedNode = Dijkstra(nodes,startNode,endNode);\r\n        const beforeTimeStartInterval = this.animate(visitedNode) + 35;\r\n        var shortestPath = constructShortestPath(nodes, startNode, endNode);\r\n        if (shortestPath === \"No path exist\") {\r\n            console.log(\"No path exist\");\r\n            return;\r\n        }\r\n        shortestPath = shortestPath.reverse();\r\n        this.animateShortestPath(shortestPath,beforeTimeStartInterval,true);\r\n        const setTimeoutAgainFk = shortestPath.length + beforeTimeStartInterval;\r\n        setTimeout(() => {\r\n            this.setState({alreadyVisualized: true})\r\n        }, TIME_OUT_CONST * (setTimeoutAgainFk + 10))\r\n    }\r\n\r\n    // visitedNode(List) = All of the nodes that makes the shortest path from start to end\r\n    // beforeTimeStartInterval(Integer) = How many nodes are visited before we found our end node\r\n    // shouldSetTimeout(Boolean) = determines if we should be using instant animation or not.\r\n    animateShortestPath(visitedNode, beforeTimeStartInterval, shouldSetTimeout) {\r\n        const newGrid = this.state.nodes.slice();\r\n        if (shouldSetTimeout) {\r\n            for (let i = 0; i < visitedNode.length; i++) {\r\n                const node = visitedNode[i];\r\n                const newNode = {\r\n                    ...node,\r\n                    isShortestPathNode: true,\r\n                };\r\n                // console.log(\"Before changing newGrid\");\r\n                // console.log(this.state.nodes);\r\n                // console.log(\"Changed node = [\" + newNode.row + \",\" + newNode.col + \"]\");\r\n                // console.log(\"After changing newGrid\");\r\n                // console.log(this.state.nodes);\r\n                setTimeout(() => {\r\n                    newGrid[node.row][node.col] = newNode;\r\n                    this.setState({nodes: newGrid});\r\n                }, 65 * (i + beforeTimeStartInterval));\r\n            }\r\n        }\r\n        // else {\r\n        //     for (let i = 0; i < visitedNode.length; i++) {\r\n        //         const node = visitedNode[i];\r\n        //         const newNode = {\r\n        //             ...node,\r\n        //             isShortestPathNode: true,\r\n        //         };\r\n        //         setTimeout(() => {\r\n        //             newGrid[node.row][node.col] = newNode;\r\n        //             if (i === visitedNode.length -1) {\r\n        //                 this.setState({nodes:newGrid})\r\n        //             }\r\n        //         }, 0);\r\n        //     }\r\n        // }\r\n    }\r\n\r\n    animate(visitedNode) {\r\n        for (let i =0; i < visitedNode.length; i++) {\r\n            const node = visitedNode[i];\r\n            const currentFinalNode = this.state.currentEndNode;\r\n            if (node.row === currentFinalNode[0] && node.col === currentFinalNode[1]) {\r\n                return i;\r\n            }\r\n            setTimeout(() => {\r\n                    const newGrid = this.state.nodes.slice();\r\n                    const newNode = {\r\n                        ...node,\r\n                        isAnimated: true,\r\n                    };\r\n                    newGrid[node.row][node.col] = newNode;\r\n                    this.setState({nodes: newGrid})},\r\n                65*i);\r\n        }\r\n    }\r\n\r\n    instantAnimationWithShortestPath() {\r\n        const {nodes,initialAnimationFinished,currentStartNode, currentEndNode} = this.state;\r\n        const startNode = nodes[currentStartNode[0]][currentStartNode[1]];\r\n        const endNode = nodes[currentEndNode[0]][currentEndNode[1]];\r\n        // console.log(nodes);\r\n        // console.log(\"start node is \" + startNode.row + \",\" + startNode.col);\r\n        // console.log(\"end node is \" + endNode.row + \",\" + endNode.col);\r\n        const visitedNode = Dijkstra(nodes,startNode,endNode);\r\n        // console.log(\"Went through Djikstra\");\r\n        const newGrid = this.state.nodes.slice();\r\n        for (let i =0; i < visitedNode.length; i++) {\r\n            const node = visitedNode[i];\r\n            const currentFinalNode = this.state.currentEndNode;\r\n            if (node.row === currentFinalNode[0] && node.col === currentFinalNode[1]) {\r\n                break;\r\n            }\r\n            const newNode = {\r\n                ...node,\r\n                isAnimated: true,\r\n            };\r\n            newGrid[node.row][node.col] = newNode;\r\n        }\r\n        // console.log(\"Before shortest path\");\r\n        var shortestPath = constructShortestPath(nodes, startNode, endNode);\r\n        if (shortestPath === \"No path exist\") {\r\n            console.log(\"No path exist\");\r\n            return;\r\n        }\r\n        shortestPath = shortestPath.reverse();\r\n        for (let i = 0; i < shortestPath.length; i++) {\r\n            const node = shortestPath[i];\r\n            const newNode = {\r\n                ...node,\r\n                isShortestPathNode: true,\r\n            };\r\n            newGrid[newNode.row][newNode.col] = newNode;\r\n        };\r\n        this.setState({nodes:newGrid});\r\n    }\r\n\r\n    clearBoard(resetAlreadyVisualized) {\r\n        const {nodes,currentStartNode,currentEndNode} = this.state;\r\n        const newGrid = this.state.nodes.slice();\r\n        for ( var row=0; row < nodes.length; row++) {\r\n            const column = nodes[row];\r\n            for (var col =0; col < column.length; col ++) {\r\n                var currentNode = column[col];\r\n                if (currentNode['isStart']) {\r\n                    // currentNode['isWall'] = false;\r\n                    currentNode['isAnimated'] = false;\r\n                    currentNode['isVisited'] = false;\r\n                    currentNode['isShortestPathNode'] = false;\r\n                    currentNode['distance'] = 0;\r\n                    newGrid[row][col] = currentNode\r\n                }\r\n                else {\r\n                    // currentNode['isWall'] = false;\r\n                    currentNode['isAnimated'] = false;\r\n                    currentNode['isVisited'] = false;\r\n                    currentNode['isShortestPathNode'] = false;\r\n                    currentNode['distance'] = \"infinity\";\r\n                    newGrid[row][col] = currentNode\r\n                }\r\n            }\r\n        }\r\n        console.log(\"After clearing board\");\r\n        // console.log(newGrid);\r\n        this.setState({nodes:newGrid})\r\n        if (resetAlreadyVisualized) {\r\n            this.setState({alreadyVisualized:false})\r\n        }\r\n    }\r\n\r\n    clearWall() {\r\n        const {nodes} = this.state;\r\n        const newGrid = this.state.nodes.slice();\r\n        for ( var row=0; row < nodes.length; row++) {\r\n            const column = nodes[row];\r\n            for (var col =0; col < column.length; col ++) {\r\n                var currentNode = column[col];\r\n                currentNode['isWall'] = false;\r\n            }\r\n        }\r\n        this.setState( {nodes:newGrid})\r\n    }\r\n\r\n\r\n    visualizeAlgorithm() {\r\n        const {algorithm} = this.state;\r\n        this.clearBoard();\r\n        if (algorithm === \"BFS\") {\r\n            this.visualizeBFS();\r\n        } else if (algorithm === \"DFS\") {\r\n            this.visualizeDFS();\r\n        } else if (algorithm === \"Djikstra\") {\r\n            this.visualizeDjikstra()\r\n            // this.instantAnimationWithShortestPath();\r\n        }\r\n    }\r\n\r\n    selectAlgorithm(event) {\r\n        this.setState({algorithm: event.target.value});\r\n        this.clearBoard();\r\n    }\r\n\r\n    render() {\r\n        const {nodes, mousePressed,algorithm, alreadyVisualized} = this.state;\r\n        return (\r\n            <div className =\"outerContainer\">\r\n                <Button className=\"button\" onClick={() => this.visualizeAlgorithm()}>\r\n                    Visualize {algorithm}\r\n                </Button>\r\n                <Button className=\"button\" onClick={() => this.clearBoard(true)}>\r\n                    Clear Board\r\n                </Button>\r\n                <Button className=\"button\" onClick={() => this.clearWall()}>\r\n                    Clear Wall\r\n                </Button>\r\n                <Button>\r\n                    <div className =\"dropdown\">\r\n                        <select className =\"AlgorithmSelect\" onChange={this.selectAlgorithm}>\r\n                            <option value=\"BFS\"> BFS</option>\r\n                            <option value=\"DFS\"> DFS</option>\r\n                            <option value=\"Djikstra\"> Djikstra </option>\r\n                        </select>\r\n                    </div>\r\n                </Button>\r\n                <ul className=\"iconList\">\r\n                    <li className=\"iconList\">\r\n                        <div className='box startNode'>\r\n                        </div>\r\n                        Start Node\r\n                    </li>\r\n                    <li className=\"iconList\">\r\n                        <div className='box endNode'>\r\n                        </div>\r\n                        End Node\r\n                    </li>\r\n                    <li className=\"iconList\">\r\n                        <div className='box'>\r\n                        </div>\r\n                        Unvisited Node\r\n                    </li>\r\n                    <li className=\"iconList\">\r\n                        <div className='box visitedNode'>\r\n                        </div>\r\n                        Visited Node\r\n                    </li>\r\n                    <li className=\"iconList\">\r\n                        <div className='box Wall'>\r\n                        </div>\r\n                        Wall\r\n                    </li>\r\n                </ul>\r\n                <div className=\"grid\">\r\n                {nodes.map((row, rowIdx) => {\r\n                    return (\r\n                        <div key={rowIdx} className={`row-${rowIdx}`}>\r\n                            {row.map((node, nodeIdx) => {\r\n                                const {isStart, isFinish,isAnimated, row, col,isWall, isShortestPathNode} = node;\r\n                                return (\r\n                                    <Node\r\n                                        key={nodeIdx}\r\n                                        isStart = {isStart}\r\n                                        isFinish = {isFinish}\r\n                                        isAnimated = {isAnimated}\r\n                                        isWall = {isWall}\r\n                                        isShortestPathNode = {isShortestPathNode}\r\n                                        onMouseDown={(row,col) => this.handleMouseDown(row,col)}\r\n                                        onMouseEnter={(row,col) => this.handleMouseEnter(row,col)}\r\n                                        mousePressed ={mousePressed}\r\n                                        onMouseUp= {() => this.handleMouseUp(row,col)}\r\n                                        onMouseOver={ () => this.handleMouseOver(row,col)}\r\n                                        row={row}\r\n                                        col={col}\r\n                                        instantAnimation = {alreadyVisualized}\r\n                                    >\r\n                                    </Node>\r\n                                );\r\n                            })}\r\n                    </div>\r\n                    );\r\n                })}\r\n            </div>\r\n        </div>);\r\n    }\r\n}","\r\nexport function BFS(grid, startNode, endNode) {\r\n    const {row,col} = startNode;\r\n    const endRow = endNode['row'];\r\n    const endCol = endNode['col'];\r\n    const queueOfVisited = [];\r\n    const visitedInOrder = [];\r\n    if (grid != null && startNode != null) {\r\n        queueOfVisited.push(startNode);\r\n    }\r\n    while (queueOfVisited.length > 0) {\r\n        const currentNode = queueOfVisited.shift();\r\n        const currentRow = currentNode['row'];\r\n        const currentCol = currentNode['col'];\r\n        visitedInOrder.push(currentNode);\r\n        currentNode['isVisited'] = true;\r\n        if (currentRow === endRow && currentCol === endCol) {\r\n            return visitedInOrder;\r\n        }\r\n        if (currentNode['isTop'] === false) {\r\n            const aboveNode = grid[currentRow-1][currentCol];\r\n            if (aboveNode['isVisited'] === false && !aboveNode['isWall']) {\r\n                queueOfVisited.push(aboveNode);\r\n                aboveNode['isVisited'] = true;\r\n            }\r\n        }\r\n        if (currentNode['isBottom'] === false) {\r\n            const belowNode = grid[currentRow+1][currentCol];\r\n            if (belowNode['isVisited'] === false && !belowNode['isWall']) {\r\n                queueOfVisited.push(belowNode);\r\n                belowNode['isVisited'] = true;\r\n            }\r\n        }\r\n        if (currentNode['isLeft'] === false) {\r\n            const leftNode = grid[currentRow][currentCol-1];\r\n            if (leftNode['isVisited'] === false && !leftNode['isWall']) {\r\n                queueOfVisited.push(leftNode);\r\n                leftNode['isVisited'] = true;\r\n            }\r\n        }\r\n        if (currentNode['isRight'] === false) {\r\n            const rightNode = grid[currentRow][currentCol+1];\r\n            if (rightNode['isVisited'] === false && !rightNode['isWall']) {\r\n                queueOfVisited.push(rightNode);\r\n                rightNode['isVisited'] = true;\r\n            }\r\n        }\r\n    }\r\n    return visitedInOrder;\r\n}\r\n\r\n","export function DFS(grid, startNode, endNode) {\n    const{row,col} = startNode;\n    const endRow = endNode['row'];\n    const endCol = endNode['col'];\n    var stack =[];\n    var returnVisitedStack = [];\n    if (grid != null && startNode != null) {\n        stack.push(startNode);\n    }\n    console.log(stack);\n    while (stack.length > 0) {\n        const currentNode = stack.pop();\n        returnVisitedStack.push(currentNode);\n        if (currentNode['isVisited'] === false) {\n            currentNode['isVisited'] = true;\n            const currentRow = currentNode['row'];\n            const currentCol = currentNode['col'];\n            if (currentRow === endRow && currentCol === endCol) {\n                return returnVisitedStack;\n            } else {\n                if (currentNode['isTop'] === false) {\n                    const topNode = grid[currentRow - 1][currentCol];\n                    if (topNode['isVisited'] === false && !topNode['isWall']) {\n                        stack.push(topNode);\n                    }\n                }\n                if (currentNode['isBottom'] === false) {\n                    const bottomNode = grid[currentRow + 1][currentCol];\n                    if (bottomNode['isVisited'] === false && !bottomNode['isWall']) {\n                        stack.push(bottomNode);\n                    }\n                }\n                if (currentNode['isLeft'] === false) {\n                    const leftNode = grid[currentRow][currentCol - 1];\n                    if (leftNode['isVisited'] === false && !leftNode['isWall']) {\n                        stack.push(leftNode);\n                    }\n                }\n                if (currentNode['isRight'] === false) {\n                    const rightNode = grid[currentRow][currentCol + 1];\n                    if (rightNode['isVisited'] === false && !rightNode['isWall']) {\n                        stack.push(rightNode);\n                    }\n                }\n            }\n        }\n    }\n    return returnVisitedStack;\n}","import React from 'react';\nimport './App.css';\nimport Path from './PathFindingVisualizer/Path';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Path></Path>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}